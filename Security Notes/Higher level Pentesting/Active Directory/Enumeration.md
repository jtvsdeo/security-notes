
-> Attack starts with a successfull exploit or client-side attack against Domain workstation or server

1. Use groups to assign permissions to member users. Goal is to target Domain Admins group.
2. Second way is gain control of Domain controller. The domain controller contains all the password hashes of every single domain user account.


After initial access to a workstation, search for group memberships in search of high-value targets.

### Things to check for
All users
All groups, including nested
Logged in Users
Service principles



## Commands

`net user /domain` will enumerate all users in an entire domain.  
If a user seems interesting, we can run `net user <user> /domain` to gather more info.

`net group /domain` will enumerate all groups in the domain.
There can be nested groups, so use a script to check that **21.2.5**


### Directory searcher
LDAP is used to query network services. This has an API that supports search functionality against AD. DirectorySearcher object searches and performs queries against an Active Directory Domain Services hierarchy using LDAP. 

This will serve as input to DirectorySearcher .NET class : `LDAP://HostName[:PortNumber][/DistinguishedName]`
Hostname = name of Domain Controller
DistinguishedName = name of domain  

Discover the hostname of the domain controller and the components of the DistinguishedName using a PowerShell command.
`[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()`
The domain name is from the Name property and the primary domain controller name is "" from the PdcRoleOwner11 property.  

Powershell Script to build Provider Path:
```
$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
$PDC = ($domainObj.PdcRoleOwner).Name
$SearchString = "LDAP://"
$SearchString += $PDC + "/"
$DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"
$SearchString += $DistinguishedName
$SearchString
```

Now that provider path is built, we can use the Directory Searcher class with LDAP provider path. 
We also need to specify a Search root so DS knows where the search starts. 

Search root takes form of an object from DirectoryEntry class. When no arguments are passed to the constructor, the SearchRoot will indicate that every search should return results from the entire Active Directory.

Now we would receive all objects in the entire domain so we need a filter.
 
Filter: samAccountType attribute,14 which is an attribute that all user, computer, and group objects have.  We can supply 0x30000000 (decimal 805306368) to the filter property to enumerate all users in the domain.

```
$Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)

$objDomain = New-Object System.DirectoryServices.DirectoryEntry

$Searcher.SearchRoot = $objDomain

$Searcher.filter="samAccountType=805306368"

$Searcher.FindAll()
```

After this we can implement a LOOP that will print each property on its own line. 
```

Foreach($obj in $Result)
{
    Foreach($prop in $obj.Properties)
    {
        $prop
    }
    
    Write-Host "------------------------"
}
```

**Full powershell script:**

```
$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()

$PDC = ($domainObj.PdcRoleOwner).Name

$SearchString = "LDAP://"

$SearchString += $PDC + "/"

$DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"

$SearchString += $DistinguishedName

$Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)

$objDomain = New-Object System.DirectoryServices.DirectoryEntry

$Searcher.SearchRoot = $objDomain

$Searcher.filter="samAccountType=805306368"

$Result = $Searcher.FindAll()

Foreach($obj in $Result)
{
    Foreach($prop in $obj.Properties)
    {
        $prop
    }
    
    Write-Host "------------------------"
}
```


### Currently Logged on Users
Requires Powerview, which is a PS script part of Powershell Empire Framework.

`Import-Module .\PowerView.ps1`
`Get-NetLoggedon -ComputerName client251` > Logged in users
`Get-NetSession -ComputerName dc01` > Active Sessions

### Service Principal Names
> When applications like Exchange, SQL, or Internet Information Services (IIS) are integrated into Active Directory, a unique service instance identifier known as a Service Principal Name (SPN) is used to associate a service on a specific server to a service account in Active Directory.

By enumerating all registered SPNs in the domain, we can obtain the IP address and port number of applications running on servers integrated with the target Active Directory

Can update the script above and filter by service principal name. Ex: \*http\*, indicating the presence of a registered web server