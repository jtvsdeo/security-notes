# Stack Based Buffer Overflow 
##  Exploiting Free CD to MP3 Converter v3.1

> To fuzz we send random bytes into an injectable field until the program crashes
### Local Fuzzing 

#### Registration Code 

![](../../../Assets/Pasted%20image%2020220722193629.png)  
  
Fuzzing the following parameters with 10000 A's does not crash the program  
&nbsp;
&nbsp;

#### Encode files upload

Moving on to files that can open. Looks like the encode files accepts .wav files
Time to create a fuzz.wav file with 10000 A's  

After attaching the program and opening the fuzz.wav file, 
The program has crashed with the message:

![](../../../Assets/Pasted%20image%2020220722195522.png)

As you can see, we can overwrite the EBP and EIP as the program tries to exec the A's pointed by the EIP 

![](../../../Assets/Pasted%20image%2020220722195454.png)

This shows that we can control the EIP which means we can execute our shellcode.

Check 10 Debugging a program for the python code for remote fuzzing



### Remote Fuzzing
> Steps to take to debug a remote program

### Steps to take if you have access
1. Check what port the tool listens on `netstat -a`
2. Use Netcat to connect to see what it accepts
3. Create a fuzzing script and `import socket` to send the payload
```
import pdb
def fuzz():
    try:
        for i in range(0,10000,500):
            buffer = b"A"*i
            print("Fuzzing %s bytes" % i)
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect(("127.0.0.1", "8888"))
            s.send(buffer)
	        breakpoint()
			s.close()
    except:
        print("Could not establish a connection")

fuzz()
```

> This script can run until it finishes despite  the program crashing. It is possible the actual listening service may not be vulnerable since our input never crashes it. However, the front-end program must also be processing this input (e.g., for syncing files), and it is vulnerable to a buffer overflow, which we can exploit through the listening service. This shows that if an input is processed at multiple locations/programs, we must be sure to debug all of them, as only one of them may be vulnerable.

So I could have a python open with a breakpoint and a debugger open side by side and just check when EIP is overwritten